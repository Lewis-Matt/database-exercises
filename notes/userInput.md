# User Input
In order to properly secure our applications, we have to assume anything that could potentially come from a user might be malicious. That is, we should assume a determined attacker will try to compromise our application through any means possible, and the primary way users interact with our application is through sending user input to our server.

We'll focus on two types of attacks in this lesson:

- SQL Injection: this can occur when we use user input as part of a database query
- XSS: this can occur when we display user input on our pages.

## SQL Injection
<hr>
We use user input as part of our database queries quite frequently. In fact, if we did not, our application would not do many useful things.

To illustrate how this could be a problem, imagine the following code runs on the backend of a product search page:

    // somewhere inside a servlet
    String searchTerm = request.getParameter("searchTerm");
    // DONT DO THIS!!!
    String sql = "SELECT * FROM products WHERE name LIKE '%" + searchTerm + "%'";
    // use the string to query the database
If a user searches for something like "watch", our SQL would look like this:
    
    SELECT * FROM products WHERE name LIKE '%watch%';

But what happens if a user searches for "apple's watch"? (note the single quote):

    SELECT * FROM products WHERE name LIKE '%apple's watch%';
This is a SQL syntax error and will most likely cause our application to error out! This is called a SQL injection vulnerability and it occurs when we use user input directly in our database queries.

### Preventing SQL Injection with Prepared Statements
A prepared statement is similar to the regular statement object we previously covered, with one key difference: it uses placeholders for potentially dangerous values (i.e. value that come from the user).

After defining a SQL query with placeholders, we then bind values to the placeholders, before executing the query. By doing this, we ensure that any external input we are using in a query is treated as a plain string or number, and does not become part of the query itself.

We could fix the SQL injection vulnerability from the previous example by using prepared statements:

    String sql = "SELECT * FROM products WHERE name LIKE ?";
    String searchTermWithWildcards = "%" + searchTerm + "%";
    
    PreparedStatement stmt = connection.prepareStatement(sql);
    stmt.setString(1, searchTermWithWildcards);
    
    ResultSet rs = stmt.executeQuery();
    while(rs.next()) {
        // do something with the search results
    }
- We define the SQL ahead of time and the query is passed to the prepareStatement method, as opposed to being passed to executeQuery.
- We defined the query with a placeholder, a ? to indicate where the value will go.
- We used the setString method to safely insert the search term into the query. There are other methods that start with .set for the other SQL data types.

  
    The setString (or the other similar) method accepts two arguments, the first is which placeholder to bind the value to, 
    starting from one. In this case we only have a single placeholder in our query, so we'll pass 1. The second argument 
    is the value to (safely) use inside of the query.

For this example, imagine we are working with our products database and wish to insert a new product into the table.

    String sql = "INSERT INTO products(name, category, price) VALUES (?, ?, ?)";
    PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

    // For the sake of easier demonstration we are using literals here
    stmt.setString(1, "hammer");
    stmt.setString(2, "tools");
    stmt.setFloat(3, 19.99);
    
    stmt.executeUpdate();
    ResultSet generatedIdResultSet = stmt.getGeneratedKeys();
- Here we first define a string variable named sql that holds a SQL statement with three placeholders in it. 
- Next we use the prepareStatement method on our connection object and pass in the predefined SQL. We also pass `Statement.RETURN_GENERATED_KEYS` in order to obtain the ids that were generated by the database.
- After the prepared statement object is created, we set values for each of the previously defined placeholders using the `setString` and `setFloat` methods. It is easier to demonstrate the concept with the literal values in the example, but in a real application the values here would probably come from elsewhere, for example, from the form values a user has filled out.
- Last, we execute the query and obtain the result set object that contains the ids that the database generated for us.

#### Summary of Prepared Statement Methods
1. `connection.prepareStatement(sql)`: Create the prepared statement object, when used with INSERT, Statement.RETURN_GENERATED_KEYS can be added
2. `statement.setXXX(idx, value)`: XXX is the type of the value, and idx is the number of the placeholder -- Bind a value to the statement
3. `statement.executeQuery()`: Execute the prepared SELECT query
4. `statement.executeUpdate()`: Execute an INSERT or UPDATE query
5. `statement.getResultSet` : Get the results of a SELECT query
6. `statement.getGeneratedKeys` : Get the generated ids from an INSERT query

## Cross Site Scripting (XSS)
<hr>
A Cross Site Scripting, or XSS, attack is one in which malicious JavaScript is inflicted on your users. This type of vulnerability can occur if we carelessly display user input on our pages.

Consider a search results page:

    <h1>Product Search Results</h1>
    <h2>Showing Results for ${searchTerm}</h2> <%-- <-- note this line --%>
    <c:forEach var="product" items="${searchResults}">
        <h3>
            ${product.name}
            <small>${product.price}</small>
        </h3>
    </c:forEach>
What if a user searches for "<script>alert('xss!')</script>"?

Our page will contain the HTML <script>alert('xss!')</script> in it, and the end user's browser will think that we meant to include inline JavaScript on the page and execute it, even though the JavaScript is not coming from us.

A more dedicated, determined, and malicious individual could write some JavaScript that does much worse things, like stealing usernames and passwords, or hijacking sessions.

We have to be on the lookout for XSS vulnerabilities whenever we display information on our page that comes from a user.

We can use the JSTL library's c:out tag for this. In general, whenever we are displaying a value that comes from the user, we should display it this way.
- c:out escapes HTML characters so that you can avoid cross-site scripting.

We can make our example above safer like this:

    <h1>Product Search Results</h1>
    <h2>Showing Results for <c:out value="${searchTerm}" /></h2>
    <c:forEach var="product" items="${searchResults}">
        <h3>
            <c:out value="${product.name}" />
            <small><c:out value="${product.price}" /></small>
        </h3>
    </c:forEach>
The out tag will take care of any HTML that happens to be in whatever we are displaying, meaning that if the original content is <script>alert('xss')</script>, it will be transformed to &lt;script&gt;alert('xss')&lt;/script&gt; which will be safely displayed on the page and not executed as JavaScript.